# ***************************************
# *     Author  Sadat Anwar 2015		*
# ***************************************


from __future__ import print_function
from os import listdir, remove, system, environ, getcwd
import os

try:
    import pypruss
except ImportError:
    pass
import struct
import mmap
import subprocess
import atp_file_parser
import sys

# get the project path
project_path = environ["BENCH_DEBUGGER"]


# Base folder fariables
temp = os.path.join(project_path, 'temp')
binary_folder = os.path.join(temp, 'bin')
assembler_folder = os.path.join(temp, 'assembler')
header_folder = os.path.join(project_path, 'src', 'headers_4W')
output_folder = os.path.join(temp, 'msp_out')

# Reset PRU binary location
reset_pru_bin = binary_folder + "reset.bin"

# PRU generated Output
msp_output = os.path.join(output_folder, "output_pattern.txt")
input_pattern = os.path.join(output_folder, "inputPattern.txt")

# PRU memory access constants
PRU_ICSS = 0x4A300000
PRU_ICSS_LEN = 512 * 1024
RAM0_START = 0x00000000

# Power up the Device by making VCC high (P8_13)
GPIO0_offset = 0x44E07000
GPIO0_size = 0x44E07fff - GPIO0_offset
GPIO_OE = 0x134
GPIO_SETDATAOUT = 0x194
GPIO_CLEARDATAOUT = 0x190
VCC = 1 << 23

# Compile binary file
# noinspection PyShadowingNames
def compile_assembler(file_name):
    result = subprocess.check_output("pasm -b " + file_name, shell=True, cwd=binary_folder)
    error_index = result.index("Error")
    if result[error_index - 2] != "0":
        print("ERROR:\t Error while compiling bin for " + file_name + " process ABORTING")
        sys.exit(1)


# Reset the GPIO on both PRU
def resetPRU(start_stop):
    for PRU in range(0, 2):
        if os.path.isfile(reset_pru_bin):
            pypruss.init()  # Init the PRU
            pypruss.open(1)  # Open PRU event 0 which is PRU0_ARM_INTERRUPT
            pypruss.pruintc_init()  # Init the interrupt controller
            pypruss.exec_program(PRU, reset_pru_bin)  # Load firmware "mem_write.bin" on PRU 0
            pypruss.wait_for_event(1)  # Wait for event 0 which is connected to PRU0_ARM_INTERRUPT
            print("PRU " + str(PRU) + " " + start_stop)
            pypruss.clear_event(1)  # Clear the event
            pypruss.exit()
        else:
            compile_assembler(os.path.join(header_folder, "reset.p"))


# init receiver
def init_receiver(fileName):
    bin_file = os.path.join(binary_folder, fileName)
    if not os.path.isfile(bin_file):
        print("WARN:\t" + bin_file + " not present, trying to create from headers_4W")
        compile_assembler(os.path.join(header_folder, fileName.replace(".bin", ".p")))
    if not os.path.isfile(bin_file):
        print("ERROR:\t" + bin_file + " not not created, ABORTING")
        sys.exit(1)
    pypruss.init()  # Init the PRU
    pypruss.open(0)  # Open PRU event 0 which is PRU0_ARM_INTERRUPT
    pypruss.pruintc_init()  # Init the interrupt controller
    pypruss.exec_program(0, bin_file)  # Load firmware "mem_write.bin" on PRU 0


def end_receiver(comparePattern):
    if os.path.isfile(msp_output):
        print("WARN:\t " + msp_output + " already exists, will now be deleted")
        remove(msp_output)
    with open(msp_output, "ab+") as out:
        out.writelines(comparePattern)
        print("LOG:\t " + msp_output + " created")
        raw_input("Press Enter to do automated compare of the output generated by MSP and expected output"
                  "of the ATP file")

## SCRIPT STARTS HERE ##
if len(sys.argv) < 3:
    if len(sys.argv) == 2:
        atp_file = sys.argv[1]
        assembler_files = atp_file_parser.parse_atp_file(atp_file)
    else:
        assembler_files = atp_file_parser.parse_atp_file(os.path.join(temp, 'mem_dump_atp.atp'))
else:
    print("usage python starter.py [relative/path/to/atp_file]")
    sys.exit(1)
if len(assembler_files) < 1:
    print("Provided ATP file did not generate any usable code, aborting")
    sys.exit(1)

# Reset the memory block to be used by PRU 0 for reading
with open("/dev/mem", "r+b") as f:
    ddr_mem = mmap.mmap(f.fileno(), PRU_ICSS_LEN, offset=PRU_ICSS)
    for x in range(0, 54):
        ddr_mem[RAM0_START + (x * 4):RAM0_START + (x * 4) + 4] = struct.pack('<L', 0)

# Delete old binary files from bin folder
allFiles = [f for f in listdir(binary_folder) if os.path.isfile(os.path.join(binary_folder, f))]
for bin_file in allFiles:
    if ".bin" in bin_file and "reset.bin" not in bin_file and "inputReceiver_PRU0.bin" not in bin_file:
        remove(os.path.join(binary_folder, bin_file))

# Reset the GPIO on both PRU
resetPRU("initialized")

# Compile all the assembler files
for assembler_file in assembler_files:
    compile_assembler(assembler_file)

# Load all assembler files to be executed
allFiles = [f for f in listdir(binary_folder) if os.path.isfile(os.path.join(binary_folder, f))]
binaries = []
for bin_file in allFiles:
    if ".bin" in bin_file and "reset.bin" not in bin_file and "inputReceiver_PRU0.bin" not in bin_file:
        binaries.append(bin_file)
binaries.sort()
# Power up VCC
with open("/dev/mem", "r+b") as f:
    mem = mmap.mmap(f.fileno(), GPIO0_size, offset=GPIO0_offset)
reg = struct.unpack("<L", mem[GPIO_OE:GPIO_OE + 4])[0]
mem[GPIO_OE:GPIO_OE + 4] = struct.pack("<L", reg & ~VCC)
mem[GPIO_SETDATAOUT:GPIO_SETDATAOUT + 4] = struct.pack("<L", VCC)

init_receiver("inputReceiver_PRU0.bin")
for binary in binaries:
    pypruss.init()  # Init the PRU
    pypruss.open(1)  # Open PRU event 0 which is PRU0_ARM_INTERRUPT
    pypruss.pruintc_init()  # Init the interrupt controller
    pypruss.exec_program(1, os.path.join(binary_folder, binary))  # Load firmware "mem_write.bin" on PRU 0
    pypruss.wait_for_event(1)  # Wait for event 0 which is connected to PRU0_ARM_INTERRUPT
    print("PRU 1 completed " + binary)
    pypruss.clear_event(1)  # Clear the event
    pypruss.exit()
# end_receiver()
raw_input("All files executed, press ENTER to shutdown device\n")



# Reset the GPIO on both PRU
resetPRU("shut down")
mem[GPIO_CLEARDATAOUT:GPIO_CLEARDATAOUT + 4] = struct.pack("<L", VCC)

with open("/dev/mem", "r+b") as f:
    ddr_mem = mmap.mmap(f.fileno(), PRU_ICSS_LEN, offset=PRU_ICSS)
    endReached = False
    x = 0
    comparePattern = ""
    lines_printed = 0
    system("clear")
    print("Printing memory dump:\n\n")
    while not endReached:
        lines_printed += 1
        local = struct.unpack('L', ddr_mem[RAM0_START + (x * 4):RAM0_START + (x * 4) + 4])
        x += 1
        if str(hex(local[0])) == "0xabcdef12L" or lines_printed >= 2000:
            if lines_printed == 2000:
                print("Scanned 2000 lines of memory but still couldnot find the exit pattern, quitting")
            break
        print(str('{0:03d}'.format(x)) + ": " + '{0:032b}'.format(local[0]))
        compareString = str('{0:032b}'.format(local[0]))
        if x > 1:
            for z in range(0, len(compareString)):
                comparePattern = comparePattern + compareString[z] + "\n"

# end the receiver
end_receiver(comparePattern)

# Automated comparision
try:
    result = subprocess.check_output("diff " + msp_output + " " + input_pattern, shell=True, cwd=output_folder)
    print("SUCCESS:\t The outputs are a match! Congratulations")
except:
    print("WARN:\t There seem to be differences in the two output files")
